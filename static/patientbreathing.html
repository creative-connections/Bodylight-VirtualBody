<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Virtualni pacient, babylon.js 1</title>
    <script src="./babylon.js"></script>
    <script src="./babylonjs.loaders.min.js"></script>
    <!--script src="./babylon.glTF2FileLoader.js"></script-->
    <script src="./pep.js"></script>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        button {
            background-color: #555555; /* Green */
            border: none;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
        }
    </style>
</head>
<body>
<button onclick="enterVR()" style="position:fixed;bottom:10px;left:300px">Enter VR</button>
<canvas id="renderCanvas" touch-action="none"></canvas> <!-- touch-action="none" for best results from PEP -->

<script>
    /*import {Patientbreathing} from './patientbreathing';
    let pb = new Patientbreathing();
    pb.attached();*/
    var canvas = document.getElementById("renderCanvas");

    var engine = null;
    var scene = null;
    var sceneToRender = null;
    var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
    var delayCreateScene = function () {
      // Create a scene.
      var scene = new BABYLON.Scene(engine);

      // Create a default skybox with an environment.
      //var hdrTexture = BABYLON.CubeTexture.CreateFromPrefilteredData("textures/environment.dds", scene);
      //var currentSkybox = scene.createDefaultSkybox(hdrTexture, true);

      // Append glTF model to scene.
      BABYLON.SceneLoader.Append("", "vpacient.gltf", scene, function (scene) {
        // Create a default arc rotate camera and light.
        scene.createDefaultCameraOrLight(true, true, true);

        // The default camera looks at the back of the asset.
        // Rotate the camera by 90 degrees to the front of the asset.
        scene.activeCamera.alpha += Math.PI/2;
        scene.activeCamera.beta += -Math.PI/3;
        scene.activeCamera.radius = 2;
      });
      scene.clearColor = BABYLON.Color3.Black();
      return scene;
    };
    window.initFunction = async function() {


      var asyncEngineCreation = async function() {
        try {
          return createDefaultEngine();
        } catch(e) {
          console.log("the available createEngine function failed. Creating the default engine instead");
          return createDefaultEngine();
        }
      }

      window.engine = await asyncEngineCreation();
      if (!engine) throw 'engine should not be null.';
      window.scene = delayCreateScene();};
    initFunction().then(() => {sceneToRender = scene
      engine.runRenderLoop(function () {
        if (sceneToRender && sceneToRender.activeCamera) {
          sceneToRender.render();
        }
      });
    });

    // Resize
    window.addEventListener("resize", function () {
      engine.resize();
    });

    function enterVR(){
      const xr = navigator.xr;
      if (xr) {
        //do webxr stuff
        window.scene.createDefaultXRExperienceAsync();
      }  else {
        console.log('WebXR not detected');
        alert('WebXR for virtual/augmented reality not detected');
      }
    }

</script>
</body>
</html>
